---
title: "The Strangest Secret of Claude Skills: Why You're Still Doing the Heavy Lifting"
date: 2026-01-24T03:00:00Z
draft: true
slug: "mcp-heads-with-agent-skills"
tags: ["AI", "Claude", "Agent Skills", "MCP", "Automation"]
categories: ["Technology", "Technical Concepts"]
description: "A deep dive into Claude's Skills architecture—stripped of marketing fluff and laid bare in technical reality."
summary: "A deep dive into Claude's Skills architecture—stripped of marketing fluff and laid bare in technical reality."
---
Disclaimer: Today's post is Devil's advocate style and is going to make to think harder, deeper and longer so read further if you dare.

Welcome to the future. It looks exactly like the past, only with more latency and new ways to leak data.

We are seeing a massive shift in how software behaves. The old way—hard-coded APIs and rigid endpoints—is dying. The new way is dynamic, agentic, and chaotic. To survive this transition, you need a standard. You need the **Model Context Protocol (MCP)**.

If you ignore this, you will spend the next five years building bespoke connectors for every database, API, and legacy system you own. That is not a career strategy; that is a dungeon.

Here is the truth about MCP, stripped of the hype, served with a side of reality.

### What is MCP? (The Concise Definition)

Stop over-complicating it. MCP is an open standard that defines how Large Language Models (LLMs) talk to external systems. It sits between the "brain" (the model) and the "world" (your data and tools).

It relies on three simple primitives:
1.  **Tools:** Functions the model can invoke (e.g., "send email," "query SQL").
2.  **Resources:** Data objects injected into context (files, records).
3.  **Prompts:** Templates that guide the model to reduce hallucinations.

It uses JSON-RPC 2.0. It is client-server. It creates a unified interface. That’s it. It is the USB cable for AI.

### Why This Matters (Stop Building Trash)

Before MCP, the industry standard was "ad-hoc chaos." Every integration was a one-off connector. You had fragmented SDKs, brittle error handling, and security holes big enough to drive a truck through.

MCP solves this by standardizing discovery and invocation. It allows the model to understand *what* a tool does, *when* to use it, and *how* to call it.

It is elegant. It is efficient. And it is the only way to scale without drowning in technical debt. You don’t need to rebuild the wheel for every new SaaS app; you just need to teach the model how to use the wheel.

### The Operational Nightmare (Or: "What Could Go Wrong?")

Of course, nothing in enterprise IT is ever simple. Just because we have a standard doesn't mean we aren't going to screw it up. Deploying MCP introduces specific, high-grade headaches.

**1. Security: The Toddler with a Chainsaw**
You are giving a probabilistic model access to your production tools. What could go wrong?
*   **Over-privileged access:** If you expose a tool called `run_any_sql`, the model *will* run SQL. And it might drop tables just to see what happens.
*   **The Fix:** Implement least-privilege "Tool Packs." Treat the model like a disgruntled intern—give it only the access it absolutely needs to do the job and nothing more.

**2. Ambiguity: The Enemy of Execution**
Models are not mind readers. They are pattern matchers. If your tool descriptions are vague, the model will fail.
*   **Vague descriptions:** "This tool interacts with the database." (Useless).
*   **Actionable descriptions:** "Fetches a customer by ID. Do not use for lists." (Better).
*   **The Fix:** Stop writing poetry. Write schemas. Use JSON Schema. If you can’t define it in code, the model can’t use it reliably.

**3. Latency: The Waiting Game**
MCP adds hops. LLM ↔ Client ↔ Server ↔ API. Every hop adds milliseconds.
*   **The Fix:** Cache aggressively. Use local proxies. If your tool takes 10 seconds to respond, the user has already closed the tab.

### MCP vs. Traditional APIs: The "Who’s in Charge?" Debate

Let’s be clear: MCP is not just another API wrapper. It represents a fundamental shift in control.

*   **Traditional APIs:** The *developer* decides which endpoint to call. The code is explicit. `if this, then that`. It is deterministic.
*   **MCP:** The *model* decides which tool to call. It is probabilistic. The model interprets the prompt, reads the metadata, and *guesses* the right move.

This makes MCP exponentially more sensitive to bad design. If your API documentation sucks, a human developer might figure it out. An LLM will just hallucinate a solution. In the traditional world, bad docs lead to a support ticket. In the MCP world, bad docs lead to a security incident.

### Session IDs: Keeping Your Context Alive

Context is memory. Without memory, you are a goldfish.

HTTP is stateless, but your workflows are not. MCP uses **Session IDs** to bridge this gap. The client and server share a unique ID (`Mcp-Session-Id`) that acts as a key for all conversation state—tools used, resources shared, intermediate results.

If you lose the session ID, you lose the context. The agent forgets who you are, what you were doing, and why you cared.

**Common failure points (don’t do this):**
*   **Stripping headers:** Your corporate reverse proxy is hungry and eats custom headers. Now the server sees every request as a new user. Debug that.
*   **Short TTLs:** If your session expires in 5 minutes, you don't have a workflow; you have a series of annoying interruptions.

### Skills vs. MCP: The "Hype" Filter

You will hear people talk about "Agent Skills" and "MCP" like they are competitors. They aren't. If you think they are, you’re missing the point.

*   **Skills (The "How"):** These are procedures. They teach the model the *rules of the road*. "How to fill out a tax form," "How to handle a P0 alert."
*   **MCP (The "What"):** These are the tools. They give the model *hands to touch the road*. "Read the database," "Post to Slack."

**Skills give the agent intelligence. MCP gives the agent reach.**

If you try to use MCP without Skills, you have a robot with hands but no brain—it can touch the stove, but it doesn't know it's hot. If you use Skills without MCP, you have a genius in a straitjacket—it knows the solution but can't do anything about it.

### The Bottom Line

MCP is a shift toward standardized, context-aware AI. It is a necessary evolution.

But let’s not kid ourselves. It is not magic. It is plumbing.

*   **Good plumbing** runs quietly in the background, delivering value without you noticing.
*   **Bad plumbing** floods the basement, ruins your data, and costs you a fortune.

Your job is to ensure MCP is the former. Define your tools clearly. Secure your access. Manage your sessions. And stop trying to hand-code connectors for every new service that pops up.

The future belongs to those who can orchestrate it. Stop building bespoke cages. Start building standard protocols.

Now, get to work.